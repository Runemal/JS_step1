/*Заданиен 1
Дан код:
var a = 1, b = 1, c, d;
c = ++a; alert(c);           // 2 Сначала увеличивается на 1 значение а, затем с присваивается этоже значение.
d = b++; alert(d);           // 1 Значение d равно 1, так как b = 1. Значение b увеличится на 1 в следующий вызов к данной переменной.
c = (2+ ++a); alert(c);      // 5 А уже равно 2, увеличивается на 1 и значение уже равно 3. В скобках проиходит сложение с 2, итого - 5.
d = (2+ b++); alert(d);      // 4 Это и есть "следующий вызов" b. Т.е. здесь b равно 2. Увеличение на 1 произойдет при последующем вызове b. Сложение в скобках дает 4.
alert(a);                    // 3 А в строке 6 уже было равно 3.
alert(b);                    // 3 С новым вызовом b увеличилась на 1 и стала равна 3.
Почему код даёт именно такие результаты?

//Задание 2
Чему будет равен x в примере ниже?
var a = 2;
var x = 1 + (a *= 2);
Ответ: 5 Запись *= - указывает, что необходимо взять значение переменной слева и умножить его на значение справа. Следует отметить, что значение переменной а также изменится.

//Задание 3*/
var a = Number(prompt('Введите число A: '), 1);
var b = Number(prompt('Введите число B: '), 1);
if (a >= 0 && b >= 0){
    alert("A - B = " + (a - b));
}
else if (a < 0 && b < 0){
    alert("A * B = " + (a * b));
}
else {
    alert("A + B = " + (a + b));
}

//Задание 4
a = Math.floor(Math.random() * 16);
console.log(a);
switch (a){
    case 0:
        alert('0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 1:
        alert('1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 2:
        alert('2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 3:
        alert('3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 4:
        alert('4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 5:
        alert('5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 6:
        alert('6, 7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 7:
        alert('7, 8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 8:
        alert('8, 9, 10, 11, 12, 13, 14, 15.');
        break;
    case 9:
        alert('9, 10, 11, 12, 13, 14, 15.');
        break;
    case 10:
        alert('10, 11, 12, 13, 14, 15.');
        break;
    case 11:
        alert('11, 12, 13, 14, 15.');
        break;
    case 12:
        alert('12, 13, 14, 15.');
        break;
    case 13:
        alert('13, 14, 15.');
        break;
    case 14:
        alert('14, 15.');
        break;
    case 15:
        alert('15.');
        break;
}

//Задание 5
function plus(a, b){
    return a + b;
}
function minus(a, b){
    return a - b;
}
function multiply(a, b){
    return a * b;
}
function split(a, b){
    if (b != 0){
        return a / b;
    }
    else{
        alert('На нуль делить нельзя! О-о');
    }
}

//Задание 6
function mathOperation(arg1, arg2, operation){
    switch (operation){
        case ('+'):
            return plus(arg1, arg2);
            break;
        case ('-'):
            return minus(arg1, arg2);
            break;
        case ('*'):
            return multiply(arg1, arg2);
            break;
        case ('/'):
            return split(arg1, arg2);
            break;
    }
}

//Задание 7
/* Сравнить null и 0. Объяснить результат.
Ответ: С физической точки зрения, когда объявлен объекты со значениями null и 0, то в памяти содержится запись лишь о значении 0. Таким образом, при сравнении null == 0, null > 0, null < 0 результат будет ЛОЖЬ. Однако, когда происходит сравнение  null >= 0 или null <= 0, происходит автоматическое приведение типов и null приравнивается к 0 и результат будет ИСТИНА. */

//Задание 8
function power(val, pow){
    if (pow == 1){
        return val;
    } else {
        return val * power(val, pow - 1);
    }
}
